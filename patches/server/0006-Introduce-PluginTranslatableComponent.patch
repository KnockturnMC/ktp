From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jatyn Stacy <jlee0964@gmail.com>
Date: Fri, 26 Nov 2021 17:23:22 -0800
Subject: [PATCH] Introduce PluginTranslatableComponent

This patch implements the plugin translatable component interface and
implementation that is an additional component that may be used in
combination with the adventure text api.

A plugin translatable component is a translatable-like component that only
holds a key that is matched to a localized message when rendered. The
difference between a translatable component and a plugin translatable
component is the fact that the translation the plugin translatable
component represents is parsed using the mini message parser and
arguments are passed in as a single template resolver.

Besides the addition of the plugin translatable component, this patch
also introduces a basic layout to allow plugins to quickly load
translator instances to supply the servers translator with translations
for the added plugin translatable components.

Co-authored-by: Bjarne Koll <lynxplay101@gmail.com>

diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/KTPTranslatableComponentFactoryImpl.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/KTPTranslatableComponentFactoryImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..d1cd9b5e9139985b02216c741f07b09d773bfe90
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/KTPTranslatableComponentFactoryImpl.java
@@ -0,0 +1,69 @@
+package dev.lynxplay.ktp.adventure.translation;
+
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.ComponentLike;
+import net.kyori.adventure.text.TranslatableComponent;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.Tag;
+import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
+import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * Straight forward implementation of the {@link KTPTranslatableComponentFactory} that is based on {@link PluginTranslationBundle}s for resolving
+ * the fallback.
+ */
+public class KTPTranslatableComponentFactoryImpl implements KTPTranslatableComponentFactory {
+
+    private final PluginTranslationBundle[] bundles;
+    private final Map<String, String> fallbackCache = new Object2ObjectOpenHashMap<>();
+    private final TagResolver tagToVanillaPlaceholder = TagResolver.resolver("arg", (argumentQueue, context) -> {
+        final String argIndex = argumentQueue.popOr(() -> "").value();
+        return Tag.inserting(Component.text("%" + argIndex + "$s"));
+    });
+
+    public KTPTranslatableComponentFactoryImpl(final PluginTranslationBundle[] bundles) {
+        this.bundles = bundles;
+    }
+
+    /**
+     * Constructs a translatable component for a given key.
+     * The translatable component will hold the {@link TranslatableComponent#key()} and {@link TranslatableComponent#args()} passed to this method.
+     * <p>
+     * Furthermore, this translatable component will have a {@link TranslatableComponent#fallback()} configured that matches the english translation
+     * of the passed key.
+     * If no translation for the key can be found at the time of this method's invocation, the fallback is not set.
+     *
+     * @param key       the key of the translatable component.
+     * @param arguments the arguments of the translatable components.
+     *
+     * @return the created translatable component.
+     */
+    @Override
+    public @NotNull TranslatableComponent translatable(@NotNull final String key, @NotNull final ComponentLike... arguments) {
+        // Check for a fallback already in the cache
+        final String cachedFallback = fallbackCache.get(key);
+        if (cachedFallback != null) return Component.translatable(key, cachedFallback, arguments);
+
+        // Search for the english translation
+        String englishTranslation = null;
+        for (final PluginTranslationBundle bundle : this.bundles) {
+            englishTranslation = bundle.findTranslation(Locale.ENGLISH, key);
+            if (englishTranslation != null) break;
+        }
+
+        // No translation
+        if (englishTranslation == null) return Component.translatable(key, arguments);
+
+        final Component fallback = MiniMessage.miniMessage().deserialize(englishTranslation, tagToVanillaPlaceholder);
+        final String serializedFallback = PlainTextComponentSerializer.plainText().serialize(fallback);
+        this.fallbackCache.put(key, serializedFallback);
+
+        return Component.translatable(key, serializedFallback, arguments);
+    }
+
+}
diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginShortcutMessageFormat.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginShortcutMessageFormat.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d1b54ec05c7cec3c848b0f66644c4ed9b97c513
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginShortcutMessageFormat.java
@@ -0,0 +1,82 @@
+package dev.lynxplay.ktp.adventure.translation;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.text.AttributedCharacterIterator;
+import java.text.AttributedString;
+import java.text.Format;
+import java.text.MessageFormat;
+import java.text.ParseException;
+import java.text.ParsePosition;
+
+/**
+ * A MessageFormat for when you don't want to format the message :)
+ */
+public class PluginShortcutMessageFormat extends MessageFormat {
+
+    private String unformattedString;
+
+    public PluginShortcutMessageFormat(@NotNull final String unformattedString) {
+        super("");
+        this.unformattedString = unformattedString;
+    }
+
+    @Override
+    public void applyPattern(@NotNull final String pattern) {
+        this.unformattedString = pattern;
+    }
+
+    @Override
+    public String toPattern() {
+        return this.unformattedString;
+    }
+
+    @Override
+    public void setFormatsByArgumentIndex(@NotNull final Format @NotNull [] newFormats) {
+    }
+
+    @Override
+    public void setFormats(@NotNull final Format @NotNull [] newFormats) {
+    }
+
+    @Override
+    public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat) {
+    }
+
+    @Override
+    public void setFormat(final int formatElementIndex, final Format newFormat) {
+    }
+
+    @NotNull
+    @Override
+    public Format @NotNull [] getFormatsByArgumentIndex() {
+        return this.getFormats();
+    }
+
+    @NotNull
+    @Override
+    public Format @NotNull [] getFormats() {
+        return new Format[0];
+    }
+
+    @Override
+    public AttributedCharacterIterator formatToCharacterIterator(final Object arguments) {
+        return new AttributedString("").getIterator();
+    }
+
+    @Override
+    public Object[] parse(final String source, final ParsePosition pos) {
+        return new Object[0];
+    }
+
+    @Override
+    public Object[] parse(final String source) throws ParseException {
+        return parse(source, null);
+    }
+
+    @Override
+    public Object parseObject(final String source, final ParsePosition pos) {
+        return source;
+    }
+
+}
diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginTranslationBundleImpl.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginTranslationBundleImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae38ab57186e8d5afed32dd65b335e22c06a26c7
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginTranslationBundleImpl.java
@@ -0,0 +1,41 @@
+package dev.lynxplay.ktp.adventure.translation;
+
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * A straight forward implementation of the plugin translation bundle that uses a fast util map.
+ */
+public final class PluginTranslationBundleImpl implements PluginTranslationBundle {
+
+    private final Map<Locale, Map<String, String>> localeTranslationMappings;
+
+    public PluginTranslationBundleImpl(@NotNull Map<Locale, Map<String, String>> localeTranslationMappings) {
+        this.localeTranslationMappings = new Object2ObjectOpenHashMap<>();
+        for (final var localeMapEntry : localeTranslationMappings.entrySet()) {
+            this.localeTranslationMappings.put(localeMapEntry.getKey(), new Object2ObjectOpenHashMap<>(localeMapEntry.getValue()));
+        }
+    }
+
+    @Override
+    public @Nullable String findTranslation(@NotNull Locale locale, @NotNull String translationKey) {
+        var translationLocale = localeTranslationMappings.get(locale);
+        if (translationLocale == null) {
+            final var requestedLocaleRange = new Locale.LanguageRange(locale.toLanguageTag());
+            translationLocale = localeTranslationMappings.get(
+                Locale.lookup(Collections.singletonList(requestedLocaleRange), localeTranslationMappings.keySet())
+            );
+        }
+
+        return translationLocale == null ? null : translationLocale.get(translationKey);
+    }
+
+}
diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginTranslatorsImpl.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginTranslatorsImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..61017343d02828b85f18311c50df5fcce1662b4e
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/PluginTranslatorsImpl.java
@@ -0,0 +1,87 @@
+package dev.lynxplay.ktp.adventure.translation;
+
+import dev.lynxplay.ktp.adventure.translation.exception.TranslationParseException;
+import dev.lynxplay.ktp.adventure.translation.parser.FilenameTranslationLocaleParser;
+import dev.lynxplay.ktp.adventure.translation.parser.JsonTranslationFileParser;
+import dev.lynxplay.ktp.adventure.translation.parser.PropertiesTranslationFileParser;
+import dev.lynxplay.ktp.adventure.translation.parser.TranslationFileParser;
+import dev.lynxplay.ktp.adventure.translation.parser.TranslationLocaleParser;
+import dev.lynxplay.ktp.adventure.translation.parser.YamlTranslationFileParser;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
+import net.kyori.adventure.text.renderer.TranslatableComponentRenderer;
+import net.kyori.adventure.translation.Translator;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.stream.Stream;
+
+/**
+ * The server specific implementation of the plugin translators interface.
+ */
+public final class PluginTranslatorsImpl implements PluginTranslators {
+
+    private final TranslationFileParser YAML_TRANSLATION_FILE_PARSER = new YamlTranslationFileParser();
+    private final TranslationFileParser PROPERTIES_TRANSLATION_FILE_PARSER = new PropertiesTranslationFileParser();
+    private final TranslationFileParser JSON_TRANSLATION_FILE_PARSER = new JsonTranslationFileParser();
+    private final TranslationLocaleParser FILENAME_TRANSLATION_LOCALE_PARSER = new FilenameTranslationLocaleParser();
+
+    @Override
+    public @NotNull KTPTranslatableComponentFactory newComponentFactory(@NotNull final PluginTranslationBundle... bundles) {
+        return new KTPTranslatableComponentFactoryImpl(bundles);
+    }
+
+    @Override
+    public @NotNull PluginTranslationBundle parseTranslationBundle(
+        @NotNull final Path translationRoot,
+        @NotNull final TranslationLocaleParser translationLocaleParser,
+        @NotNull final TranslationFileParser translationFileParser
+    ) throws TranslationParseException {
+        try (final Stream<Path> translationFileStream = Files.walk(translationRoot)) {
+            final List<Path> translationFiles = translationFileStream.filter(Files::isRegularFile).toList();
+
+            final Map<Locale, Map<String, String>> localeTranslationMappings = new Reference2ObjectOpenHashMap<>();
+            for (final var translationFile : translationFiles) {
+                final Locale locale = translationLocaleParser.parseLocale(translationFile);
+                final Map<String, String> translations = translationFileParser.parseTranslations(translationFile);
+
+                localeTranslationMappings.computeIfAbsent(locale, i -> new Reference2ObjectOpenHashMap<>()).putAll(translations);
+            }
+
+            return new PluginTranslationBundleImpl(localeTranslationMappings);
+        } catch (final IOException e) {
+            throw new TranslationParseException("Failed to read translation files from disk", e);
+        }
+    }
+
+    @Override
+    public @NotNull Translator createPluginTranslator(@NotNull final String namespace,
+                                                      @NotNull final PluginTranslationBundle pluginTranslationBundle) {
+        return new SinglePluginTranslator(namespace, pluginTranslationBundle);
+    }
+
+    @Override
+    public @NotNull TranslationFileParser yamlTranslationFileParser() {
+        return this.YAML_TRANSLATION_FILE_PARSER;
+    }
+
+    @Override
+    public @NotNull TranslationFileParser jsonTranslationFileParser() {
+        return this.JSON_TRANSLATION_FILE_PARSER;
+    }
+
+    @Override
+    public @NotNull TranslationFileParser propertiesTranslationFileParser() {
+        return this.PROPERTIES_TRANSLATION_FILE_PARSER;
+    }
+
+    @Override
+    public @NotNull TranslationLocaleParser filenameTranslationLocaleParser() {
+        return FILENAME_TRANSLATION_LOCALE_PARSER;
+    }
+
+}
diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/SinglePluginTranslator.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/SinglePluginTranslator.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c05494b185f836f0cf6db50a47b6f36287c5630
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/SinglePluginTranslator.java
@@ -0,0 +1,66 @@
+package dev.lynxplay.ktp.adventure.translation;
+
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TranslatableComponent;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.Tag;
+import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
+import net.kyori.adventure.translation.Translator;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.text.MessageFormat;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * An implementation of the adventure translator interface that holds onto a {@link PluginTranslationBundle} of a specific plugin's namespace.
+ */
+public class SinglePluginTranslator implements Translator {
+
+    private final String namespaceSuffixedDot;
+    private final Key key;
+    private final PluginTranslationBundle translationBundle;
+
+    @SuppressWarnings("PatternValidation") // Key#key(String,String) will perform pattern validation, we do not have to enforce the pattern early.
+    public SinglePluginTranslator(@NotNull final String namespace, @NotNull final PluginTranslationBundle translationBundle) {
+        this.namespaceSuffixedDot = namespace + ".";
+        this.key = Key.key(namespace, "translations");
+        this.translationBundle = translationBundle;
+    }
+
+    @Override
+    public @NotNull Key name() {
+        return this.key;
+    }
+
+    @Override
+    public @Nullable Component translate(@NotNull final TranslatableComponent component, @NotNull final Locale locale) {
+        final String key = component.key();
+        if (!key.startsWith(namespaceSuffixedDot)) return null;
+
+        var translation = this.translationBundle.findTranslation(locale, key);
+        if (translation == null) translation = this.translationBundle.findTranslation(Locale.ENGLISH, key);
+
+        if (translation == null) return null;
+
+        final List<Component> args = component.args();
+
+        return MiniMessage.miniMessage().deserialize(translation, TagResolver.resolver("arg", (argumentQueue, context) -> {
+            final String argIndex = argumentQueue.popOr(() -> "").value();
+            return Tag.inserting(args.get(Integer.parseInt(argIndex)));
+        }));
+    }
+
+    @Override
+    public @Nullable MessageFormat translate(@NotNull final String key, @NotNull final Locale locale) {
+        if (!key.startsWith(namespaceSuffixedDot)) return null;
+
+        var translation = this.translationBundle.findTranslation(locale, key);
+        if (translation == null) translation = this.translationBundle.findTranslation(Locale.ENGLISH, key);
+
+        return translation == null ? null : new PluginShortcutMessageFormat(translation);
+    }
+
+}
diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/FilenameTranslationLocaleParser.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/FilenameTranslationLocaleParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee5ff959e783071cee22832d3699bdec27babc13
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/FilenameTranslationLocaleParser.java
@@ -0,0 +1,30 @@
+package dev.lynxplay.ktp.adventure.translation.parser;
+
+import dev.lynxplay.ktp.adventure.translation.exception.TranslationLocaleParserException;
+import net.kyori.adventure.translation.Translator;
+import org.apache.commons.lang.StringUtils;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.Locale;
+
+/**
+ * An implementation of the {@link TranslationLocaleParser} that parses the locale of a file simply based on the base file name, ignoring the
+ * extension.
+ * <p>
+ * Example given:
+ * The file 'plugins/Example/language/en.json' would be parsed to {@link java.util.Locale#ENGLISH}.
+ * Notably this uses {@link net.kyori.adventure.translation.Translator#parseLocale(String)}, so country code and variants are also accepted.
+ */
+public final class FilenameTranslationLocaleParser implements TranslationLocaleParser {
+
+    @Override
+    public @NotNull Locale parseLocale(@NotNull Path path) throws TranslationLocaleParserException {
+        final var fileName = StringUtils.substringBeforeLast(path.getFileName().toString(), ".");
+        final var parsedLocale = Translator.parseLocale(fileName);
+        if (parsedLocale == null) throw new TranslationLocaleParserException("Failed to parse locale from " + path.getFileName().toString());
+
+        return parsedLocale;
+    }
+
+}
diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/JsonTranslationFileParser.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/JsonTranslationFileParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..333a05075a27386d008ac8974c2a51cd87fd084b
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/JsonTranslationFileParser.java
@@ -0,0 +1,83 @@
+package dev.lynxplay.ktp.adventure.translation.parser;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSyntaxException;
+import dev.lynxplay.ktp.adventure.translation.exception.TranslationParseException;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+
+/**
+ * A json based implementation of the translation file parser.
+ * Json files are parsed by constructing the translation key as a combination of each node above a value.
+ * <p>
+ * Example given:
+ * <pre>
+ * {
+ *   "message": {
+ *     "player": {
+ *       "join": "You joined the game"
+ *     }
+ *   }
+ * }
+ * </pre>
+ * would be parsed into a single translation, namely the translation key 'message.player.join' mapped to 'You joined the game'.
+ */
+public final class JsonTranslationFileParser implements TranslationFileParser {
+
+    private static final int PATH_STRING_BUFFER_LENGTH = 256; // Allocating more characters to the string builder to hopefully avoid re-allocation
+    // while building.
+    private final Gson gsonInstance = new GsonBuilder().disableHtmlEscaping().create();
+
+    @Override
+    public @NotNull Map<String, String> parseTranslations(@NotNull Path file) throws TranslationParseException {
+        try (
+            final var inputStream = Files.newInputStream(file);
+            final var inputStreamReader = new InputStreamReader(inputStream)
+        ) {
+            final var result = new Object2ObjectOpenHashMap<String, String>();
+            final var root = gsonInstance.fromJson(inputStreamReader, JsonElement.class);
+
+            crawl(result, new StringBuilder(PATH_STRING_BUFFER_LENGTH), root);
+
+            return result;
+        } catch (final IOException e) {
+            throw new TranslationParseException("Failed to read the translation file", e);
+        } catch (JsonSyntaxException e) {
+            throw new TranslationParseException("Failed to parse the translation file's json file", e);
+        }
+    }
+
+    /**
+     * The crawl method is a recursive method that crawls through the entire tree represented by the passed element and stores each value found
+     * inside the passed flattenedMap.
+     *
+     * @param flattenedMap the result map that flattened values will be inserted into.
+     * @param path         the current path to the passed element onto which new elements should be appended.
+     * @param element      the current root element which should be crawled.
+     */
+    private void crawl(@NotNull final Map<String, String> flattenedMap, @NotNull final StringBuilder path, @NotNull final JsonElement element) {
+        if (element instanceof JsonObject jsonObject) {
+            for (final var entry : jsonObject.entrySet()) {
+                if (!path.isEmpty()) path.append("."); // Only pre-pend if the path already has elements
+                path.append(entry.getKey()); // Push path
+
+                crawl(flattenedMap, path, entry.getValue());
+
+                path.setLength(Math.max(0, path.length() - (entry.getKey().length() + 1))); // Drop path addition, might be -1 on the root element.
+            }
+        } else if (element instanceof JsonPrimitive jsonPrimitive) {
+            flattenedMap.put(path.toString(), jsonPrimitive.getAsString());
+        }
+    }
+
+}
diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/PropertiesTranslationFileParser.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/PropertiesTranslationFileParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..40f2218d978494fd5bfdbddab57bb422f5d09eb3
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/PropertiesTranslationFileParser.java
@@ -0,0 +1,41 @@
+package dev.lynxplay.ktp.adventure.translation.parser;
+
+import dev.lynxplay.ktp.adventure.translation.exception.TranslationParseException;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.PropertyResourceBundle;
+
+/**
+ * A properties-based implementation of the translation file parser.
+ * Since properties files cannot contain hierarchical data, the mappings are taken verbatim from the file.
+ * <p>
+ * Example given:
+ * <pre>
+ *  message.player.join=You joined the game
+ * </pre>
+ * would be parsed as a translation mapping the key 'message.player.join' to the value 'You joined the game'.
+ * </p>
+ */
+public final class PropertiesTranslationFileParser implements TranslationFileParser {
+
+    @Override
+    public @NotNull Map<String, String> parseTranslations(@NotNull Path file) throws TranslationParseException {
+        final var translations = new Object2ObjectOpenHashMap<String, String>();
+
+        try (final var reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {
+            final var bundle = new PropertyResourceBundle(reader);
+            bundle.keySet().forEach(key -> translations.put(key, bundle.getString(key)));
+        } catch (final IOException e) {
+            throw new TranslationParseException("Failed to read the translation file", e);
+        }
+
+        return translations;
+    }
+
+}
diff --git a/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/YamlTranslationFileParser.java b/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/YamlTranslationFileParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..454b0e47c14103e05b5efdf88ccce965188ac6eb
--- /dev/null
+++ b/src/main/java/dev/lynxplay/ktp/adventure/translation/parser/YamlTranslationFileParser.java
@@ -0,0 +1,53 @@
+package dev.lynxplay.ktp.adventure.translation.parser;
+
+import dev.lynxplay.ktp.adventure.translation.exception.TranslationParseException;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+
+/**
+ * A yaml based implementation of the translation file parser.
+ * Yaml files are parsed by constructing the translation key as a combination of each node above a value.
+ * <p>
+ * Example given:
+ * <pre>
+ * message:
+ *   player:
+ *     join: 'You joined the game'
+ * </pre>
+ * would be parsed into a single translation, namely the translation key 'message.player.join' mapped to 'You joined the game'.
+ */
+public final class YamlTranslationFileParser implements TranslationFileParser {
+
+    @Override
+    public @NotNull Map<String, String> parseTranslations(@NotNull Path file) throws TranslationParseException {
+        try {
+            final var fileContent = Files.readString(file, StandardCharsets.UTF_8);
+            final var result = new Object2ObjectOpenHashMap<String, String>();
+
+            final var yaml = new YamlConfiguration();
+            yaml.loadFromString(fileContent);
+
+            for (final var key : yaml.getKeys(true)) {
+                final var value = yaml.getString(key, null);
+                if (value == null) continue;
+
+                result.put(key, value);
+            }
+
+            return result;
+        } catch (final IOException e) {
+            throw new TranslationParseException("Failed to read the translation file", e);
+        } catch (InvalidConfigurationException e) {
+            throw new TranslationParseException("Failed to parse the translation file's yaml file", e);
+        }
+    }
+
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index b6881d548b3bdb0399ae597872c86779eb77723f..60c7bff9274077cf2682e376ae05077b0c9799c4 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -295,6 +295,7 @@ public final class CraftServer implements Server {
     public static Exception excessiveVelEx; // Paper - Velocity warnings
     private final io.papermc.paper.logging.SysoutCatcher sysoutCatcher = new io.papermc.paper.logging.SysoutCatcher(); // Paper
     private final CraftPotionBrewer potionBrewer = new CraftPotionBrewer(); // Paper
+    private final dev.lynxplay.ktp.adventure.translation.PluginTranslators pluginTranslators; // KTP - plugin translators - server instance
 
     static {
         ConfigurationSerialization.registerClass(CraftOfflinePlayer.class);
@@ -381,6 +382,7 @@ public final class CraftServer implements Server {
             MapPalette.setMapColorCache(new CraftMapColorCache(this.logger));
         }
         datapackManager = new io.papermc.paper.datapack.PaperDatapackManager(console.getPackRepository()); // Paper
+        this.pluginTranslators = new dev.lynxplay.ktp.adventure.translation.PluginTranslatorsImpl(); // KTP - plugin translators - server instance
     }
 
     public boolean getCommandBlockOverride(String command) {
@@ -2915,4 +2917,14 @@ public final class CraftServer implements Server {
     }
 
     // Paper end
+    // KTP start
+    /**
+     * Returns the plugin translator of the server that plugins may use to register custom translations.
+     * @return the plugin translator instance.
+     */
+    @Override
+    public @org.jetbrains.annotations.NotNull dev.lynxplay.ktp.adventure.translation.PluginTranslators pluginTranslators() {
+        return this.pluginTranslators;
+    }
+    // KTP end
 }
diff --git a/src/test/java/dev/lynxplay/ktp/adventure/translation/KTPTranslatableComponentFactoryImplTest.java b/src/test/java/dev/lynxplay/ktp/adventure/translation/KTPTranslatableComponentFactoryImplTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..22c06100d0b151485a67ddabc329280e00e44ae5
--- /dev/null
+++ b/src/test/java/dev/lynxplay/ktp/adventure/translation/KTPTranslatableComponentFactoryImplTest.java
@@ -0,0 +1,28 @@
+package dev.lynxplay.ktp.adventure.translation;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TranslatableComponent;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.Locale;
+import java.util.Map;
+
+public class KTPTranslatableComponentFactoryImplTest {
+
+    @Test
+    public void testProperFallbackCreation() {
+        final KTPTranslatableComponentFactoryImpl factory = new KTPTranslatableComponentFactoryImpl(new PluginTranslationBundle[]{
+            new PluginTranslationBundleImpl(Map.of(
+                Locale.ENGLISH, Map.of("test", "<green>Everything worked for test <arg:1>")
+            ))
+        });
+
+        final TranslatableComponent translatable = factory.translatable("test", Component.text("first test"));
+        Assert.assertEquals(1, translatable.args().size());
+        Assert.assertEquals(Component.text("first test"), translatable.args().get(0));
+        Assert.assertEquals("test", translatable.key());
+        Assert.assertEquals("Everything worked for test %1$s", translatable.fallback());
+    }
+
+}
