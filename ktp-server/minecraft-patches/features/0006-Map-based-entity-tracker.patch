From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Bjarne Koll <git@lynxplay.dev>
Date: Sat, 27 Sep 2025 15:50:07 +0200
Subject: [PATCH] Map based entity tracker

Replaces the seenBy reference set with a map, allowing the tracker to
correctly maintain vanilla state, including all players vanilla would be
tracking.

The visibility api introduced by bukkit is implemented with a
pre-computed filtered list of effective trackers on the seen by tracker.

diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index 09af66f4da588835027f09406c2beb20372eb0e7..cbbbbb3ca323be2502f0846aed7895d297324628 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1176,10 +1176,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     public class TrackedEntity implements ServerEntity.Synchronizer, ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity { // Paper - optimise entity tracker
         public final ServerEntity serverEntity;
-        final Entity entity;
+        public final Entity entity; // KTP - map based tracker
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        public final io.papermc.paper.network.PaperSeenByTracker seenBy; // Paper - Perf: optimise map impl // KTP - map based tracker
 
         // Paper start - optimise entity tracker
         private long lastChunkUpdate = -1L;
@@ -1214,7 +1214,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
                 // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy.theoretical())) { // KTP - map based tracker
                     final ServerPlayer player = conn.getPlayer();
                     if (!players.contains(player)) {
                         this.removePlayer(player);
@@ -1226,7 +1226,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         @Override
         public final void moonrise$removeNonTickThreadPlayers() {
             boolean foundToRemove = false;
-            for (final ServerPlayerConnection conn : this.seenBy) {
+            for (final ServerPlayerConnection conn : this.seenBy.theoretical()) { // KTP - map based tracker
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(conn.getPlayer())) {
                     foundToRemove = true;
                     break;
@@ -1237,7 +1237,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 return;
             }
 
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy.theoretical())) { // KTP - map based tracker
                 ServerPlayer player = conn.getPlayer();
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
                     this.removePlayer(player);
@@ -1252,7 +1252,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             if (this.seenBy.isEmpty()) {
                 return;
             }
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy.theoretical())) { // KTP - map based tracker
                 ServerPlayer player = conn.getPlayer();
                 this.removePlayer(player);
             }
@@ -1265,6 +1265,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - optimise entity tracker
 
         public TrackedEntity(final Entity entity, final int range, final int updateInterval, final boolean trackDelta) {
+            this.seenBy = new io.papermc.paper.network.PaperSeenByTracker(this); // KTP - map based tracker
             this.serverEntity = new ServerEntity(ChunkMap.this.level, entity, updateInterval, trackDelta, this, this.seenBy); // Paper
             this.entity = entity;
             this.range = range;
@@ -1283,7 +1284,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         @Override
         public void sendToTrackingPlayers(Packet<? super ClientGamePacketListener> packet) {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy.effective()) { // KTP - map based tracker
                 serverPlayerConnection.send(packet);
             }
         }
@@ -1298,7 +1299,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         @Override
         public void sendToTrackingPlayersFiltered(Packet<? super ClientGamePacketListener> packet, Predicate<ServerPlayer> filter) {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy.effective()) { // KTP - map based tracker
                 if (filter.test(serverPlayerConnection.getPlayer())) {
                     serverPlayerConnection.send(packet);
                 }
@@ -1306,19 +1307,14 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void broadcastRemoved() {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy.effective()) { // KTP - map based tracker
                 this.serverEntity.removePairing(serverPlayerConnection.getPlayer());
             }
         }
 
         public void removePlayer(ServerPlayer player) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
-            if (this.seenBy.remove(player.connection)) {
-                this.serverEntity.removePairing(player);
-                if (this.seenBy.isEmpty()) {
-                    ChunkMap.this.level.debugSynchronizers().dropEntity(this.entity);
-                }
-            }
+            this.seenBy.remove(player.connection); // KTP - map based tracker
         }
 
         public void updatePlayer(ServerPlayer player) {
@@ -1349,25 +1345,31 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     flag = false;
                 }
                 // CraftBukkit end
-                if (flag) {
-                    if (this.seenBy.add(player.connection)) {
-                        // Paper start - entity tracking events
-                        if (io.papermc.paper.event.player.PlayerTrackEntityEvent.getHandlerList().getRegisteredListeners().length == 0 || new io.papermc.paper.event.player.PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity()).callEvent()) {
-                        this.serverEntity.addPairing(player);
-                        if (this.seenBy.size() == 1) {
-                            ChunkMap.this.level.debugSynchronizers().registerEntity(this.entity);
-                        }
+                // KTP start - map based tracker - move into own method
+                if (flag) this.seenBy.add(player.connection);
+                else this.seenBy.remove(player.connection);
+                // KTP end - map based tracker - move into own method
+            }
+        }
 
-                        ChunkMap.this.level.debugSynchronizers().startTrackingEntity(player, this.entity);
-                        }
-                        // Paper end - entity tracking events
-                        this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
-                    }
-                } else {
-                    this.removePlayer(player);
-                }
+        // KTP start - map based tracker - move into own method
+        public void addPairing(final ServerPlayer serverPlayer, final io.papermc.paper.network.PaperSeenByTracker.TrackerData trackerData) {
+            if (this.seenBy.effective().size() == 1) {
+                ChunkMap.this.level.debugSynchronizers().registerEntity(this.entity);
+            }
+
+            ChunkMap.this.level.debugSynchronizers().startTrackingEntity(serverPlayer, this.entity);
+            this.serverEntity.addPairing(serverPlayer, trackerData);
+            this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
+        }
+
+        public void removePairing(final ServerPlayer serverPlayer) {
+            this.serverEntity.removePairing(serverPlayer);
+            if (this.seenBy.isEmpty()) {
+                ChunkMap.this.level.debugSynchronizers().dropEntity(this.entity);
             }
         }
+        // KTP end - map based tracker - move into own method
 
         private int scaledRange(int trackingDistance) {
             return ChunkMap.this.level.getServer().getScaledTrackingDistance(trackingDistance);
diff --git a/net/minecraft/server/level/ServerEntity.java b/net/minecraft/server/level/ServerEntity.java
index 638432a2e6506d3db6a25c068a33eeafb13cf0d6..01cae89a76848f2888dabb5c2c89ba4ea57c6e45 100644
--- a/net/minecraft/server/level/ServerEntity.java
+++ b/net/minecraft/server/level/ServerEntity.java
@@ -70,9 +70,9 @@ public class ServerEntity {
     private boolean wasOnGround;
     @Nullable
     private List<SynchedEntityData.DataValue<?>> trackedDataValues;
-    private final Set<net.minecraft.server.network.ServerPlayerConnection> trackedPlayers; // Paper
+    private final io.papermc.paper.network.PaperSeenByTracker trackedPlayers; // KTP - map based tracker
 
-    public ServerEntity(ServerLevel level, Entity entity, int updateInterval, boolean trackDelta, ServerEntity.Synchronizer synchronizer, final Set<net.minecraft.server.network.ServerPlayerConnection> trackedPlayers) { // Paper
+    public ServerEntity(ServerLevel level, Entity entity, int updateInterval, boolean trackDelta, ServerEntity.Synchronizer synchronizer, final io.papermc.paper.network.PaperSeenByTracker trackedPlayers) { // Paper  // KTP - map based tracker)
         this.trackedPlayers = trackedPlayers; // Paper
         this.level = level;
         this.synchronizer = synchronizer;
@@ -122,7 +122,7 @@ public class ServerEntity {
                 MapId mapId = itemFrame.cachedMapId; // Paper - Perf: Cache map ids on item frames
                 MapItemSavedData savedData = MapItem.getSavedData(mapId, this.level);
                 if (savedData != null) {
-                    for (final net.minecraft.server.network.ServerPlayerConnection connection : this.trackedPlayers) { // Paper
+                    for (final net.minecraft.server.network.ServerPlayerConnection connection : this.trackedPlayers.effective()) { // Paper // KTP - map based tracker
                         final ServerPlayer serverPlayer = connection.getPlayer(); // Paper
                         savedData.tickCarriedBy(serverPlayer, item);
                         Packet<?> updatePacket = savedData.getUpdatePacket(mapId, serverPlayer);
@@ -305,14 +305,29 @@ public class ServerEntity {
         player.connection.send(new ClientboundRemoveEntitiesPacket(this.entity.getId()));
     }
 
+    @io.papermc.paper.annotation.DoNotUse
     public void addPairing(ServerPlayer player) {
+    // KTP  start - map based tracker - pass tracker data
+        addPairing(player, null);
+    }
+
+    public void addPairing(ServerPlayer player, final @Nullable io.papermc.paper.network.PaperSeenByTracker.TrackerData trackerData) {
+    // KTP  end - map based tracker - pass tracker data
         List<Packet<? super ClientGamePacketListener>> list = new ArrayList<>();
-        this.sendPairingData(player, list::add);
+        this.sendPairingData(player, list::add, trackerData); // KTP  end - map based tracker - pass tracker data
         player.connection.send(new ClientboundBundlePacket(list));
         this.entity.startSeenByPlayer(player);
     }
 
+    @io.papermc.paper.annotation.DoNotUse
     public void sendPairingData(ServerPlayer player, Consumer<Packet<ClientGamePacketListener>> consumer) {
+    // KTP  start - map based tracker - pass tracker data
+        sendPairingData(player, consumer, null);
+    }
+
+    public void sendPairingData(ServerPlayer player, Consumer<Packet<ClientGamePacketListener>> consumer,
+                                final @Nullable io.papermc.paper.network.PaperSeenByTracker.TrackerData trackerData) {
+    // KTP  start - map based tracker - pass tracker data
         if (this.entity.isRemoved()) {
             // CraftBukkit start - Remove useless error spam, just return
             // LOGGER.warn("Fetching packet for removed entity {}", this.entity);
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index a05c02a3298f5e57d19e6d9d853428d00158814a..c3c032f4581f6fbf8e4845119eac0218030e3fd5 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -682,7 +682,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             }
             final net.minecraft.server.level.ServerEntity serverEntity = tracker.serverEntity;
             final List<net.minecraft.network.protocol.Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>> list = new java.util.ArrayList<>();
-            serverEntity.sendPairingData(player, list::add);
+            serverEntity.sendPairingData(player, list::add, tracker.seenBy.theoreticalData(player.connection)); // KTP  end - map based tracker - pass tracker data
             player.connection.send(new net.minecraft.network.protocol.game.ClientboundBundlePacket(list));
         }
     }
