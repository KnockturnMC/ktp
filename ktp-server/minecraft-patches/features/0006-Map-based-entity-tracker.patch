From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Bjarne Koll <git@lynxplay.dev>
Date: Sat, 27 Sep 2025 15:50:07 +0200
Subject: [PATCH] Map based entity tracker

Replaces the seenBy reference set with a map, allowing the tracker to
correctly maintain vanilla state, including all players vanilla would be
tracking.

The visibility api introduced by bukkit is implemented with a
pre-computed filtered list of effective trackers on the seen by tracker.

diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index b7c16eeee03ac1183d3d26bd8ee1b13afd620f61..f7b877dabda47afe3910096087fa60ed11deacf2 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1176,10 +1176,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     public class TrackedEntity implements ServerEntity.Synchronizer, ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity { // Paper - optimise entity tracker
         public final ServerEntity serverEntity;
-        final Entity entity;
+        public final Entity entity; // KTP - map based tracker
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        public final io.papermc.paper.network.PaperSeenByTracker seenBy; // Paper - Perf: optimise map impl // KTP - map based tracker
 
         // Paper start - optimise entity tracker
         private long lastChunkUpdate = -1L;
@@ -1214,7 +1214,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
                 // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy.theoretical())) { // KTP - map based tracker
                     final ServerPlayer player = conn.getPlayer();
                     if (!players.contains(player)) {
                         this.removePlayer(player);
@@ -1226,7 +1226,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         @Override
         public final void moonrise$removeNonTickThreadPlayers() {
             boolean foundToRemove = false;
-            for (final ServerPlayerConnection conn : this.seenBy) {
+            for (final ServerPlayerConnection conn : this.seenBy.theoretical()) { // KTP - map based tracker
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(conn.getPlayer())) {
                     foundToRemove = true;
                     break;
@@ -1237,7 +1237,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 return;
             }
 
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy.theoretical())) { // KTP - map based tracker
                 ServerPlayer player = conn.getPlayer();
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
                     this.removePlayer(player);
@@ -1252,7 +1252,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             if (this.seenBy.isEmpty()) {
                 return;
             }
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy.theoretical())) { // KTP - map based tracker
                 ServerPlayer player = conn.getPlayer();
                 this.removePlayer(player);
             }
@@ -1265,6 +1265,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - optimise entity tracker
 
         public TrackedEntity(final Entity entity, final int range, final int updateInterval, final boolean trackDelta) {
+            this.seenBy = new io.papermc.paper.network.PaperSeenByTracker(this); // KTP - map based tracker
             this.serverEntity = new ServerEntity(ChunkMap.this.level, entity, updateInterval, trackDelta, this, this.seenBy); // Paper
             this.entity = entity;
             this.range = range;
@@ -1283,7 +1284,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         @Override
         public void sendToTrackingPlayers(Packet<? super ClientGamePacketListener> packet) {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy.effective()) { // KTP - map based tracker
                 serverPlayerConnection.send(packet);
             }
         }
@@ -1298,7 +1299,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         @Override
         public void sendToTrackingPlayersFiltered(Packet<? super ClientGamePacketListener> packet, Predicate<ServerPlayer> filter) {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy.effective()) { // KTP - map based tracker
                 if (filter.test(serverPlayerConnection.getPlayer())) {
                     serverPlayerConnection.send(packet);
                 }
@@ -1306,19 +1307,14 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void broadcastRemoved() {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy.effective()) { // KTP - map based tracker
                 this.serverEntity.removePairing(serverPlayerConnection.getPlayer());
             }
         }
 
         public void removePlayer(ServerPlayer player) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
-            if (this.seenBy.remove(player.connection)) {
-                this.serverEntity.removePairing(player);
-                if (this.seenBy.isEmpty()) {
-                    ChunkMap.this.level.debugSynchronizers().dropEntity(this.entity);
-                }
-            }
+            this.seenBy.remove(player.connection); // KTP - map based tracker
         }
 
         public void updatePlayer(ServerPlayer player) {
@@ -1349,25 +1345,31 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     flag = false;
                 }
                 // CraftBukkit end
-                if (flag) {
-                    if (this.seenBy.add(player.connection)) {
-                        // Paper start - entity tracking events
-                        if (io.papermc.paper.event.player.PlayerTrackEntityEvent.getHandlerList().getRegisteredListeners().length == 0 || new io.papermc.paper.event.player.PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity()).callEvent()) {
-                        this.serverEntity.addPairing(player);
-                        if (this.seenBy.size() == 1) {
-                            ChunkMap.this.level.debugSynchronizers().registerEntity(this.entity);
-                        }
+                // KTP start - map based tracker - move into own method
+                if (flag) this.seenBy.add(player.connection);
+                else this.seenBy.remove(player.connection);
+                // KTP end - map based tracker - move into own method
+            }
+        }
 
-                        ChunkMap.this.level.debugSynchronizers().startTrackingEntity(player, this.entity);
-                        }
-                        // Paper end - entity tracking events
-                        this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
-                    }
-                } else {
-                    this.removePlayer(player);
-                }
+        // KTP start - map based tracker - move into own method
+        public void addPairing(final ServerPlayer serverPlayer) {
+            if (this.seenBy.effective().size() == 1) {
+                ChunkMap.this.level.debugSynchronizers().registerEntity(this.entity);
+            }
+
+            ChunkMap.this.level.debugSynchronizers().startTrackingEntity(serverPlayer, this.entity);
+            this.serverEntity.addPairing(serverPlayer);
+            this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
+        }
+
+        public void removePairing(final ServerPlayer serverPlayer) {
+            this.serverEntity.removePairing(serverPlayer);
+            if (this.seenBy.isEmpty()) {
+                ChunkMap.this.level.debugSynchronizers().dropEntity(this.entity);
             }
         }
+        // KTP end - map based tracker - move into own method
 
         private int scaledRange(int trackingDistance) {
             return ChunkMap.this.level.getServer().getScaledTrackingDistance(trackingDistance);
diff --git a/net/minecraft/server/level/ServerEntity.java b/net/minecraft/server/level/ServerEntity.java
index 638432a2e6506d3db6a25c068a33eeafb13cf0d6..a0bd6f31b810fbbf29cd0c8ca5d8dc6c7a5fd7d6 100644
--- a/net/minecraft/server/level/ServerEntity.java
+++ b/net/minecraft/server/level/ServerEntity.java
@@ -70,9 +70,9 @@ public class ServerEntity {
     private boolean wasOnGround;
     @Nullable
     private List<SynchedEntityData.DataValue<?>> trackedDataValues;
-    private final Set<net.minecraft.server.network.ServerPlayerConnection> trackedPlayers; // Paper
+    private final io.papermc.paper.network.PaperSeenByTracker trackedPlayers; // KTP - map based tracker
 
-    public ServerEntity(ServerLevel level, Entity entity, int updateInterval, boolean trackDelta, ServerEntity.Synchronizer synchronizer, final Set<net.minecraft.server.network.ServerPlayerConnection> trackedPlayers) { // Paper
+    public ServerEntity(ServerLevel level, Entity entity, int updateInterval, boolean trackDelta, ServerEntity.Synchronizer synchronizer, final io.papermc.paper.network.PaperSeenByTracker trackedPlayers) { // Paper  // KTP - map based tracker)
         this.trackedPlayers = trackedPlayers; // Paper
         this.level = level;
         this.synchronizer = synchronizer;
@@ -122,7 +122,7 @@ public class ServerEntity {
                 MapId mapId = itemFrame.cachedMapId; // Paper - Perf: Cache map ids on item frames
                 MapItemSavedData savedData = MapItem.getSavedData(mapId, this.level);
                 if (savedData != null) {
-                    for (final net.minecraft.server.network.ServerPlayerConnection connection : this.trackedPlayers) { // Paper
+                    for (final net.minecraft.server.network.ServerPlayerConnection connection : this.trackedPlayers.effective()) { // Paper // KTP - map based tracker
                         final ServerPlayer serverPlayer = connection.getPlayer(); // Paper
                         savedData.tickCarriedBy(serverPlayer, item);
                         Packet<?> updatePacket = savedData.getUpdatePacket(mapId, serverPlayer);
